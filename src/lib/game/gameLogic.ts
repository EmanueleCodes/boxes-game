import type { GameRoom } from "../types"
import { generateBoxGroup } from "./boxGenerator"

/**
 * Check if game can start (2+ players, game not started)
 */
export function canStartGame(room: GameRoom): boolean {
    return room.gameState === 'notStarted' && room.players.size >= 2
}

/**
 * Start the game (happens ONCE when game begins)
 * - Transitions gameState: 'notStarted' → 'started'
 * - Initializes round 1
 * - Sets roundState: 'notStarted' → 'notStarted' (round hasn't started yet)
 * - Does NOT generate boxes (that's startRound's job)
 */
export function startGame(room: GameRoom): void {
    if (!canStartGame(room)) {
        throw new Error('Cannot start game: need 2+ players and game must be in notStarted state')
    }

    // Initialize game: set to round 1, game is now started
    room.currentRound = 1
    room.gameState = 'started'
    room.roundState = 'notStarted' // Round hasn't started yet, boxes not generated
}

/**
 * Start a round (happens 10 times - once per round)
 * - Generates boxes for current round using pattern system
 * - Sets roundData with boxes and correctCount
 * - Sets startedAt timestamp
 * - Transitions roundState: 'notStarted' → 'showingBoxes'
 * - Requires: gameState must be 'started'
 */
export function startRound(room: GameRoom): void {
    if (room.gameState !== 'started') {
        throw new Error(`Cannot start round: game must be in 'started' state, currently '${room.gameState}'`)
    }
    if (room.roundState !== 'notStarted') {
        throw new Error(`Cannot start round: round must be in 'notStarted' state, currently '${room.roundState}'`)
    }

    // Generate box group based on current round
    const boxGroup = generateBoxGroup(room.currentRound)

    room.roundData = {
        boxes: boxGroup.boxes,
        correctCount: boxGroup.correctCount,
        startedAt: Date.now(),
        // Store animation metadata for client-side rendering
        animation: boxGroup.animation,
    }
    room.roundState = 'showingBoxes'
}

/**
 * Transition from showingBoxes → answering
 * (After 3 seconds of boxes being visible)
 */
export function transitionToAnswering(room: GameRoom): void {
    if (room.roundState !== 'showingBoxes') {
        throw new Error(`Cannot transition to answering: must be in 'showingBoxes' state, currently '${room.roundState}'`)
    }
    room.roundState = 'answering'
}

/**
 * Transition from answering → showResults
 * (After collecting all answers, calculate scores)
 */
export function transitionToResults(room: GameRoom): void {
    if (room.roundState !== 'answering') {
        throw new Error(`Cannot transition to results: must be in 'answering' state, currently '${room.roundState}'`)
    }
    room.roundState = 'showResults'
}

/**
 * Move to next round or finish game
 * - If round < 10: increment round, reset roundState to 'notStarted'
 * - If round === 10: set gameState to 'finished'
 */
export function nextRound(room: GameRoom): void {
    if (room.roundState !== 'showResults') {
        throw new Error(`Cannot move to next round: must be in 'showResults' state, currently '${room.roundState}'`)
    }

    if (room.currentRound >= 10) {
        room.gameState = 'finished'
        room.roundState = 'notStarted' // No more rounds
    } else {
        room.currentRound++
        room.roundState = 'notStarted' // Ready for next round to start
        // Note: boxes will be generated by startRound() when round actually begins
    }
}